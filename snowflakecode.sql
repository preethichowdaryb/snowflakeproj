-- Warehouses & DB
CREATE WAREHOUSE IF NOT EXISTS ETL_WH  WAREHOUSE_SIZE = 'XSMALL' AUTO_SUSPEND = 60 AUTO_RESUME = TRUE;
CREATE WAREHOUSE IF NOT EXISTS BI_WH   WAREHOUSE_SIZE = 'XSMALL' AUTO_SUSPEND = 60 AUTO_RESUME = TRUE;

CREATE DATABASE IF NOT EXISTS RETAIL_DWH;
USE DATABASE RETAIL_DWH;

CREATE SCHEMA IF NOT EXISTS RAW;
CREATE SCHEMA IF NOT EXISTS DW;
CREATE SCHEMA IF NOT EXISTS MART;
CREATE SCHEMA IF NOT EXISTS UTIL;

USE SCHEMA RAW ;

-- File format for CSVs
CREATE OR REPLACE FILE FORMAT UTIL.FF_CSV
  TYPE = 'CSV'
  FIELD_DELIMITER = ','
  SKIP_HEADER = 1
  NULL_IF = ('', 'NULL')
  EMPTY_FIELD_AS_NULL = TRUE
  FIELD_OPTIONALLY_ENCLOSED_BY = '"';

CREATE OR REPLACE STAGE RAW.CUSTOMERS_STAGE FILE_FORMAT = UTIL.FF_CSV;
CREATE OR REPLACE STAGE RAW.PRODUCTS_STAGE  FILE_FORMAT = UTIL.FF_CSV;
CREATE OR REPLACE STAGE RAW.SALES_STAGE     FILE_FORMAT = UTIL.FF_CSV;

--Landing the files to raw tables

CREATE OR REPLACE TABLE RAW.CUSTOMERS_RAW (
  CUSTOMER_ID STRING,
  FIRST_NAME  STRING,
  LAST_NAME   STRING,
  EMAIL       STRING,
  SIGNUP_DATE DATE,
  CITY        STRING
);

CREATE OR REPLACE TABLE RAW.PRODUCTS_RAW (
  PRODUCT_ID   STRING,
  PRODUCT_NAME STRING,
  CATEGORY     STRING,
  UNIT_PRICE   NUMBER(10,2),
  UNIT_COST    NUMBER(10,2),
  IS_ACTIVE    BOOLEAN
);

CREATE OR REPLACE TABLE RAW.SALES_RAW (
  SALE_ID     STRING,
  SALE_DATE   DATE,
  CUSTOMER_ID STRING,
  PRODUCT_ID  STRING,
  QUANTITY    NUMBER(10,0),
  UNIT_PRICE  NUMBER(10,2)
);

COPY INTO RAW.CUSTOMERS_RAW
  FROM @RAW.CUSTOMERS_STAGE
  FILE_FORMAT = (FORMAT_NAME = 'UTIL.FF_CSV')
  PATTERN = '.*';

COPY INTO RAW.PRODUCTS_RAW
  FROM @RAW.PRODUCTS_STAGE
  FILE_FORMAT = (FORMAT_NAME = 'UTIL.FF_CSV')
  PATTERN = '.*';

COPY INTO RAW.SALES_RAW
  FROM @RAW.SALES_STAGE
  FILE_FORMAT = (FORMAT_NAME = 'UTIL.FF_CSV')
  PATTERN = '.*';

--sanity checks
SELECT 'CUSTOMERS', COUNT(*) FROM RAW.CUSTOMERS_RAW
UNION ALL SELECT 'PRODUCTS', COUNT(*) FROM RAW.PRODUCTS_RAW
UNION ALL SELECT 'SALES', COUNT(*) FROM RAW.SALES_RAW;

--star schema 
USE WAREHOUSE ETL_WH;
USE DATABASE RETAIL_DWH;

--create date dimension
CREATE SCHEMA IF NOT EXISTS DW;

CREATE OR REPLACE TABLE DW.DIM_DATE (
  DATE_SK        NUMBER PRIMARY KEY,
  DATE_VALUE     DATE,
  YEAR           NUMBER(4),
  QUARTER        NUMBER(1),
  MONTH          NUMBER(2),
  DAY            NUMBER(2),
  DAY_OF_WEEK    NUMBER(1),     -- ISO 1=Mon .. 7=Sun
  MONTH_NAME     STRING,        -- JAN, FEB, ...
  DAY_NAME       STRING,        -- MON, TUE, ...
  IS_WEEKEND     BOOLEAN
);

-- Configure your date range
SET START_DATE = '2020-01-01'::DATE;
SET END_DATE   = '2034-12-31'::DATE;  -- inclusive

-- Insert dates (ROWCOUNT must be a constant; 60000 > 15 years of days)
INSERT INTO DW.DIM_DATE
WITH seq AS (
  SELECT DATEADD('day', SEQ4(), $START_DATE) AS d
  FROM TABLE(GENERATOR(ROWCOUNT => 60000))  -- constant!
)
SELECT
  TO_NUMBER(TO_CHAR(d, 'YYYYMMDD'))   AS DATE_SK,
  d                                   AS DATE_VALUE,
  YEAR(d)                              AS YEAR,
  QUARTER(d)                           AS QUARTER,
  MONTH(d)                             AS MONTH,
  DAY(d)                               AS DAY,
  DAYOFWEEKISO(d)                      AS DAY_OF_WEEK,
  TO_CHAR(d,'MON')                     AS MONTH_NAME,
  TO_CHAR(d,'DY')                      AS DAY_NAME,
  DAYOFWEEKISO(d) IN (6,7)             AS IS_WEEKEND
FROM seq
WHERE d <= $END_DATE;

--customer dimension(scd 2- keeps history of past customer)
CREATE OR REPLACE TABLE DW.DIM_CUSTOMER (
  CUSTOMER_SK        NUMBER IDENTITY PRIMARY KEY,   -- surrogate key
  CUSTOMER_ID        STRING,                         -- natural key from source
  FIRST_NAME         STRING,
  LAST_NAME          STRING,
  EMAIL              STRING,
  CITY               STRING,
  SIGNUP_DATE        DATE,
  ROW_HASH           STRING,                         -- detect attribute changes
  EFFECTIVE_START_TS TIMESTAMP,
  EFFECTIVE_END_TS   TIMESTAMP,
  IS_CURRENT         BOOLEAN
);

-- Helper view to compute a hash over change-driving columns
CREATE OR REPLACE VIEW UTIL.V_CUSTOMERS_WITH_HASH AS
SELECT
  CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL, CITY, SIGNUP_DATE,
  MD5(TO_JSON(OBJECT_CONSTRUCT(
     'FN', FIRST_NAME, 'LN', LAST_NAME, 'EMAIL', EMAIL, 'CITY', CITY, 'SD', SIGNUP_DATE
  ))) AS ROW_HASH
FROM RAW.CUSTOMERS_RAW;

-- Initial bootstrap load: one “current” row per customer
INSERT INTO DW.DIM_CUSTOMER
(CUSTOMER_ID,FIRST_NAME,LAST_NAME,EMAIL,CITY,SIGNUP_DATE,ROW_HASH,EFFECTIVE_START_TS,EFFECTIVE_END_TS,IS_CURRENT)
SELECT
  CUSTOMER_ID,FIRST_NAME,LAST_NAME,EMAIL,CITY,SIGNUP_DATE,ROW_HASH,
  CURRENT_TIMESTAMP(), '9999-12-31'::TIMESTAMP, TRUE
FROM UTIL.V_CUSTOMERS_WITH_HASH;

--product dimension(scd1 -overwrite)
CREATE OR REPLACE TABLE DW.DIM_PRODUCT (
  PRODUCT_SK    NUMBER IDENTITY PRIMARY KEY,
  PRODUCT_ID    STRING,
  PRODUCT_NAME  STRING,
  CATEGORY      STRING,
  UNIT_PRICE    NUMBER(10,2),
  UNIT_COST     NUMBER(10,2),
  IS_ACTIVE     BOOLEAN
);

-- Initial load (MERGE supports re-runs)
MERGE INTO DW.DIM_PRODUCT d
USING RAW.PRODUCTS_RAW s
  ON d.PRODUCT_ID = s.PRODUCT_ID
WHEN MATCHED THEN UPDATE SET
  PRODUCT_NAME = s.PRODUCT_NAME,
  CATEGORY     = s.CATEGORY,
  UNIT_PRICE   = s.UNIT_PRICE,
  UNIT_COST    = s.UNIT_COST,
  IS_ACTIVE    = s.IS_ACTIVE
WHEN NOT MATCHED THEN INSERT (PRODUCT_ID,PRODUCT_NAME,CATEGORY,UNIT_PRICE,UNIT_COST,IS_ACTIVE)
VALUES (s.PRODUCT_ID,s.PRODUCT_NAME,s.CATEGORY,s.UNIT_PRICE,s.UNIT_COST,s.IS_ACTIVE);

--sales fact table
CREATE OR REPLACE TABLE DW.FACT_SALES (
  SALE_ID       STRING PRIMARY KEY,               -- degenerate dim (keep in fact)
  DATE_SK       NUMBER,                           -- FK → DIM_DATE
  CUSTOMER_SK   NUMBER,                           -- FK → DIM_CUSTOMER (current row)
  PRODUCT_SK    NUMBER,                           -- FK → DIM_PRODUCT
  QUANTITY      NUMBER(10,0),
  UNIT_PRICE    NUMBER(10,2),
  EXTENDED_AMT  NUMBER(12,2)                      -- QUANTITY * UNIT_PRICE
);

--load raw to fact_sales
INSERT INTO DW.FACT_SALES
(SALE_ID, DATE_SK, CUSTOMER_SK, PRODUCT_SK, QUANTITY, UNIT_PRICE, EXTENDED_AMT)
SELECT
  s.SALE_ID,
  TO_NUMBER(TO_CHAR(s.SALE_DATE,'YYYYMMDD'))                 AS DATE_SK,
  dc.CUSTOMER_SK,
  dp.PRODUCT_SK,
  s.QUANTITY,
  s.UNIT_PRICE,
  s.QUANTITY * s.UNIT_PRICE                                  AS EXTENDED_AMT
FROM RAW.SALES_RAW s
LEFT JOIN DW.DIM_CUSTOMER dc
  ON dc.CUSTOMER_ID = s.CUSTOMER_ID
LEFT JOIN DW.DIM_PRODUCT dp
  ON dp.PRODUCT_ID  = s.PRODUCT_ID;

  -- Sanity checks
SELECT 'DIM_DATE' T, COUNT(*) FROM DW.DIM_DATE
UNION ALL SELECT 'DIM_CUSTOMER', COUNT(*) FROM DW.DIM_CUSTOMER
UNION ALL SELECT 'DIM_PRODUCT', COUNT(*) FROM DW.DIM_PRODUCT
UNION ALL SELECT 'FACT_SALES', COUNT(*) FROM DW.FACT_SALES;

-- Orphans (should be 0 ideally)
SELECT COUNT(*) AS missing_customer
FROM DW.FACT_SALES f LEFT JOIN DW.DIM_CUSTOMER d ON f.CUSTOMER_SK = d.CUSTOMER_SK
WHERE d.CUSTOMER_SK IS NULL;

SELECT COUNT(*) AS missing_product
FROM DW.FACT_SALES f LEFT JOIN DW.DIM_PRODUCT p ON f.PRODUCT_SK = p.PRODUCT_SK
WHERE p.PRODUCT_SK IS NULL;

-- Example: revenue by month & product category
SELECT
  dd.YEAR,
  dd.MONTH,
  dp.CATEGORY,
  SUM(f.EXTENDED_AMT) AS REVENUE
FROM DW.FACT_SALES f
JOIN DW.DIM_DATE    dd ON dd.DATE_SK = f.DATE_SK
JOIN DW.DIM_PRODUCT dp ON dp.PRODUCT_SK = f.PRODUCT_SK
GROUP BY 1,2,3
ORDER BY 1,2,3;

--Handle updates to customer info (SCD) and new transactions (CDC).
CREATE OR REPLACE STREAM RAW.CUSTOMERS_RAW_STRM ON TABLE RAW.CUSTOMERS_RAW;
CREATE OR REPLACE STREAM RAW.PRODUCTS_RAW_STRM  ON TABLE RAW.PRODUCTS_RAW;
CREATE OR REPLACE STREAM RAW.SALES_RAW_STRM     ON TABLE RAW.SALES_RAW;

--delta helper views
CREATE OR REPLACE VIEW UTIL.V_CUSTOMERS_DELTA AS
SELECT 
  r.*, 
  MD5(TO_JSON(OBJECT_CONSTRUCT_KEEP_NULL(*))) AS ROW_HASH
FROM RAW.CUSTOMERS_RAW_STRM r;

CREATE OR REPLACE VIEW UTIL.V_PRODUCTS_DELTA AS SELECT * FROM RAW.PRODUCTS_RAW_STRM;
CREATE OR REPLACE VIEW UTIL.V_SALES_DELTA    AS SELECT * FROM RAW.SALES_RAW_STRM;

--scd2 for customers 
-- expire task
CREATE OR REPLACE TASK UTIL.TK_DIM_CUSTOMER_EXPIRE
  WAREHOUSE = ETL_WH              -- choose a warehouse to run this task
  SCHEDULE = 'USING CRON 0 * * * * UTC'  -- runs every hour; adjust as needed
AS
UPDATE DW.DIM_CUSTOMER d
SET 
    EFFECTIVE_END_TS = CURRENT_TIMESTAMP(),
    IS_CURRENT       = FALSE
FROM (
    SELECT CUSTOMER_ID, ROW_HASH 
    FROM UTIL.V_CUSTOMERS_DELTA
) s
WHERE d.CUSTOMER_ID = s.CUSTOMER_ID
  AND d.IS_CURRENT  = TRUE
  AND d.ROW_HASH   <> s.ROW_HASH;

--insert task
CREATE OR REPLACE TASK UTIL.TK_DIM_CUSTOMER_INSERT
  WAREHOUSE = ETL_WH
  AFTER UTIL.TK_DIM_CUSTOMER_EXPIRE
AS
INSERT INTO DW.DIM_CUSTOMER
(CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL, CITY, SIGNUP_DATE, ROW_HASH,
 EFFECTIVE_START_TS, EFFECTIVE_END_TS, IS_CURRENT)
SELECT
  s.CUSTOMER_ID,
  s.FIRST_NAME,
  s.LAST_NAME,
  s.EMAIL,
  s.CITY,
  s.SIGNUP_DATE,
  s.ROW_HASH,
  CURRENT_TIMESTAMP(), '9999-12-31'::TIMESTAMP, TRUE
FROM UTIL.V_CUSTOMERS_DELTA s
LEFT JOIN DW.DIM_CUSTOMER d
  ON d.CUSTOMER_ID = s.CUSTOMER_ID
 AND d.IS_CURRENT = TRUE
WHERE d.CUSTOMER_ID IS NULL       -- new customer
   OR d.ROW_HASH <> s.ROW_HASH;   -- attributes changed

--scd1 for products
USE WAREHOUSE ETL_WH;
USE DATABASE RETAIL_DWH;


CREATE OR REPLACE TASK UTIL.TK_DIM_PRODUCT_UPSERT
  WAREHOUSE = ETL_WH
  SCHEDULE  = 'USING CRON 5 */1 * * * America/Chicago'
AS
MERGE INTO DW.DIM_PRODUCT d
USING UTIL.V_PRODUCTS_DELTA s
  ON d.PRODUCT_ID = s.PRODUCT_ID
WHEN MATCHED THEN UPDATE SET
  d.PRODUCT_NAME = s.PRODUCT_NAME,
  d.CATEGORY     = s.CATEGORY,
  d.UNIT_PRICE   = s.UNIT_PRICE,
  d.UNIT_COST    = s.UNIT_COST,
  d.IS_ACTIVE    = s.IS_ACTIVE
WHEN NOT MATCHED THEN INSERT
  (PRODUCT_ID, PRODUCT_NAME, CATEGORY, UNIT_PRICE, UNIT_COST, IS_ACTIVE)
VALUES
  (s.PRODUCT_ID, s.PRODUCT_NAME, s.CATEGORY, s.UNIT_PRICE, s.UNIT_COST, s.IS_ACTIVE);

-- Enable the task
ALTER TASK UTIL.TK_DIM_PRODUCT_UPSERT RESUME;

--cdc for sales_fact 
CREATE OR REPLACE TASK UTIL.TK_FACT_SALES_INSERT
  WAREHOUSE = ETL_WH
  SCHEDULE  = 'USING CRON 10 */1 * * * America/Chicago'
AS
INSERT INTO DW.FACT_SALES
  (SALE_ID, DATE_SK, CUSTOMER_SK, PRODUCT_SK, QUANTITY, UNIT_PRICE, EXTENDED_AMT)
SELECT
  s.SALE_ID,
  TO_NUMBER(TO_CHAR(s.SALE_DATE,'YYYYMMDD'))           AS DATE_SK,
  COALESCE(dc.CUSTOMER_SK, -1)                          AS CUSTOMER_SK,
  COALESCE(dp.PRODUCT_SK , -1)                          AS PRODUCT_SK,
  s.QUANTITY,
  s.UNIT_PRICE,
  s.QUANTITY * s.UNIT_PRICE                             AS EXTENDED_AMT
FROM UTIL.V_SALES_DELTA s
LEFT JOIN DW.DIM_CUSTOMER dc
  ON dc.CUSTOMER_ID = s.CUSTOMER_ID
 AND dc.IS_CURRENT  = TRUE
LEFT JOIN DW.DIM_PRODUCT dp
  ON dp.PRODUCT_ID  = s.PRODUCT_ID;
--scheduling and enabling
-- Use the right context
USE DATABASE RETAIL_DWH;
USE SCHEMA UTIL;

-- 1) Temporarily suspend the ROOT of the DAG
ALTER TASK UTIL.TK_DIM_CUSTOMER_EXPIRE SUSPEND;

-- 2) Resume the CHILD (now allowed since root is suspended)
ALTER TASK UTIL.TK_DIM_CUSTOMER_INSERT RESUME;

-- 3) Re-enable the DAG by resuming the ROOT
ALTER TASK UTIL.TK_DIM_CUSTOMER_EXPIRE RESUME;

-- 4) Resume independent tasks
ALTER TASK UTIL.TK_DIM_PRODUCT_UPSERT  RESUME;
ALTER TASK UTIL.TK_FACT_SALES_INSERT   RESUME;

-- (Optional) Verify states
SHOW TASKS IN SCHEMA UTIL;

--monitoring
-- Stream backlog
SELECT 'CUSTOMERS', COUNT(*) FROM RAW.CUSTOMERS_RAW_STRM
UNION ALL SELECT 'PRODUCTS', COUNT(*) FROM RAW.PRODUCTS_RAW_STRM
UNION ALL SELECT 'SALES', COUNT(*) FROM RAW.SALES_RAW_STRM;

-- Task history
SELECT * FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY())
ORDER BY SCHEDULED_TIME DESC LIMIT 50;

--optimized views for analysts

USE WAREHOUSE ETL_WH;
USE DATABASE RETAIL_DWH;

CREATE SCHEMA IF NOT EXISTS MART;

-- Optional: an analyst role to grant to
CREATE ROLE IF NOT EXISTS ANALYST_ROLE;
GRANT USAGE ON DATABASE RETAIL_DWH TO ROLE ANALYST_ROLE;
GRANT USAGE ON SCHEMA MART        TO ROLE ANALYST_ROLE;


-- =========================================================
-- PII masking policy (email)
--    - Visible in full to privileged roles
--    - Masked for everyone else
-- =========================================================
USE SCHEMA UTIL;

CREATE OR REPLACE MASKING POLICY UTIL.MP_EMAIL_MASK AS (val STRING) RETURNS STRING ->
  CASE
    WHEN CURRENT_ROLE() IN ('ACCOUNTADMIN','SYSADMIN','DATA_SCIENTIST_ROLE','ANALYST_PRIV_ROLE') THEN val
    ELSE REGEXP_REPLACE(val,'(^.).*(@.*$)','\\1***\\2')
  END;

-- Apply to table column (policy follows into secure views)
ALTER TABLE DW.DIM_CUSTOMER
  MODIFY COLUMN EMAIL
  SET MASKING POLICY UTIL.MP_EMAIL_MASK;


-- =========================================================
-- (Optional) Row Access Policy by region/city
-- =========================================================
CREATE OR REPLACE ROW ACCESS POLICY UTIL.RAP_CITY AS (CITY STRING) RETURNS BOOLEAN ->
  CASE
    WHEN CURRENT_ROLE() IN ('ACCOUNTADMIN','SYSADMIN','ANALYST_PRIV_ROLE') THEN TRUE
    WHEN CURRENT_ROLE() = 'REGION_EAST_ROLE'   THEN CITY IN ('New York','Boston')
    WHEN CURRENT_ROLE() = 'REGION_CENTRAL_ROLE' THEN CITY IN ('Chicago','Dallas')
    WHEN CURRENT_ROLE() = 'REGION_WEST_ROLE'    THEN CITY IN ('San Francisco','Los Angeles','Denver')
    ELSE FALSE
  END;

-- Attach if you need row-level filtering on customer
-- ALTER TABLE DW.DIM_CUSTOMER ADD ROW ACCESS POLICY UTIL.RAP_CITY ON (CITY);


-- =========================================================
-- SECURE Views (only expose what analysts need)
-- =========================================================
USE SCHEMA MART;

-- Current customers only, PII masked via policy
CREATE OR REPLACE SECURE VIEW MART.V_DIM_CUSTOMER AS
SELECT
  CUSTOMER_SK, CUSTOMER_ID, FIRST_NAME, LAST_NAME, EMAIL, CITY, SIGNUP_DATE
FROM DW.DIM_CUSTOMER
WHERE IS_CURRENT = TRUE;

CREATE OR REPLACE SECURE VIEW MART.V_DIM_PRODUCT AS
SELECT
  PRODUCT_SK, PRODUCT_ID, PRODUCT_NAME, CATEGORY, UNIT_PRICE, IS_ACTIVE
FROM DW.DIM_PRODUCT;

CREATE OR REPLACE SECURE VIEW MART.V_DIM_DATE AS
SELECT
  DATE_SK, DATE_VALUE, YEAR, QUARTER, MONTH, DAY, DAY_OF_WEEK, MONTH_NAME, DAY_NAME, IS_WEEKEND
FROM DW.DIM_DATE;

-- Star join view for easy analysis
CREATE OR REPLACE SECURE VIEW MART.V_SALES_DETAIL AS
SELECT
  f.SALE_ID,
  d.YEAR, d.QUARTER, d.MONTH, d.DAY, d.DATE_VALUE,
  c.CUSTOMER_SK, c.CUSTOMER_ID, c.FIRST_NAME, c.LAST_NAME, c.EMAIL, c.CITY,
  p.PRODUCT_SK, p.PRODUCT_ID, p.PRODUCT_NAME, p.CATEGORY,
  f.QUANTITY, f.UNIT_PRICE, f.EXTENDED_AMT
FROM DW.FACT_SALES f
JOIN DW.DIM_DATE    d ON d.DATE_SK    = f.DATE_SK
JOIN DW.DIM_CUSTOMER c ON c.CUSTOMER_SK = f.CUSTOMER_SK   AND c.IS_CURRENT = TRUE
JOIN DW.DIM_PRODUCT  p ON p.PRODUCT_SK  = f.PRODUCT_SK;

-- Convenience monthly aggregate (non-materialized; BI tools can query this)
CREATE OR REPLACE SECURE VIEW MART.V_SALES_MONTHLY_CATEGORY AS
SELECT
  d.YEAR,
  d.MONTH,
  p.CATEGORY,
  SUM(f.QUANTITY)     AS QTY,
  SUM(f.EXTENDED_AMT) AS REVENUE
FROM DW.FACT_SALES f
JOIN DW.DIM_DATE d   ON d.DATE_SK = f.DATE_SK
JOIN DW.DIM_PRODUCT p ON p.PRODUCT_SK = f.PRODUCT_SK
GROUP BY d.YEAR, d.MONTH, p.CATEGORY;


-- =========================================================
-- (Optional) Performance helpers
--    Search Optimization is billable; enable only if you need fast NK lookups.
-- =========================================================
USE SCHEMA DW;

-- Speed up equality lookups by NK in joins (optional)
ALTER TABLE DW.DIM_CUSTOMER ADD SEARCH OPTIMIZATION ON EQUALITY(CUSTOMER_ID);
ALTER TABLE DW.DIM_PRODUCT  ADD SEARCH OPTIMIZATION ON EQUALITY(PRODUCT_ID);

-- If FACT is very large and most queries filter by date, clustering can help
-- ALTER TABLE DW.FACT_SALES CLUSTER BY (DATE_SK);


-- =========================================================
-- Grants to analysts
-- =========================================================
USE SCHEMA MART;

GRANT SELECT,update ON ALL VIEWS IN SCHEMA MART TO ROLE ANALYST_ROLE;
GRANT SELECT ON FUTURE VIEWS IN SCHEMA MART TO ROLE ANALYST_ROLE;

-- Let analysts run queries
GRANT USAGE ON WAREHOUSE ETL_WH TO ROLE ANALYST_ROLE;






























